"""
Finance Agent - Mamadou
Handles bills, budgets, portfolio, and financial tracking

Integrates with EdgeLab adapters for data acquisition:
- BrowserAdapter: Live scraping via agent-browser CLI / Clawd Chrome extension
- PolymarketAdapter: Prediction market prices and sentiment
- YFinanceAdapter: Traditional stock/ETF data
"""
import re
import asyncio
import logging
from typing import Dict, Any, List, Optional, Tuple
from .base import BaseAgent
from .browser_polymarket import ChromeExtensionTrader
from .finance_wizard_llm import generate_wizard_prompt

logger = logging.getLogger(__name__)

# Import Polymarket BTC 15m skill
try:
    from skills.polymarket_btc_15m.skill_interface import analyze_btc_15m_direction, quick_call
    POLYMARKET_SKILL_AVAILABLE = True
except ImportError:
    POLYMARKET_SKILL_AVAILABLE = False

# Import EdgeLab adapters
try:
    from ..edgelab.adapters import (
        BrowserAdapter,
        PolymarketAdapter,
        YFinanceAdapter,
        AdapterRegistry,
    )
    EDGELAB_AVAILABLE = True
except ImportError as e:
    EDGELAB_AVAILABLE = False
    BrowserAdapter = None
    PolymarketAdapter = None
    logger.warning(f"EdgeLab adapters not available - some features disabled: {e}")


class FinanceAgent(BaseAgent):
    """
    Finance Agent (Mamadou) - handles all financial decisions
    
    Responsibilities:
    - Budget enforcement (monthly/daily spend caps)
    - Cost approvals for contractor jobs
    - Spend tracking and reporting
    - Portfolio management (add/edit/remove holdings)
    - Bill management
    """
    
    def __init__(self):
        super().__init__(
            agent_id="finance",
            name="Mamadou",
            description="Finance Manager - Bills, budgets, portfolio tracking",
            emoji="ğŸ’°"
        )
        # Wizard state per session (in production, use session storage)
        self.wizard_state: Dict[str, Any] = {}
        self.start()  # Auto-start
    
    def _get_metrics(self) -> Dict[str, Any]:
        """Get finance-specific metrics"""
        try:
            holdings = self.get_holdings_from_db()
            total_value = sum(h.get("value", 0) for h in holdings)
            return {
                "portfolio_value": total_value,
                "holdings_count": len(holdings),
            }
        except Exception:
            return {}
    
    def get_holdings_from_db(self) -> List[Dict[str, Any]]:
        """Get portfolio holdings from database"""
        from sqlalchemy import text
        from ..storage.database import get_db_session
        
        db = get_db_session()
        try:
            holdings = db.execute(
                text("SELECT ticker, shares, asset_type FROM portfolio_holdings WHERE portfolio_name = 'Lamido Main'")
            ).fetchall()
            
            return [
                {"ticker": h[0], "shares": float(h[1]), "type": h[2] or "Stock"}
                for h in holdings
            ]
        except Exception:
            return []
        finally:
            db.close()
    
    def add_holding(self, ticker: str, shares: float, asset_type: str = "Stock") -> Tuple[bool, str]:
        """Add or update a holding in the portfolio"""
        from sqlalchemy import text
        from ..storage.database import get_db_session
        
        ticker = ticker.upper().strip()
        db = get_db_session()
        try:
            existing = db.execute(
                text("SELECT id, shares FROM portfolio_holdings WHERE ticker = :ticker AND portfolio_name = 'Lamido Main'"),
                {"ticker": ticker}
            ).fetchone()
            
            if existing:
                db.execute(
                    text("UPDATE portfolio_holdings SET shares = :shares, asset_type = :asset_type, updated_at = CURRENT_TIMESTAMP WHERE ticker = :ticker AND portfolio_name = 'Lamido Main'"),
                    {"ticker": ticker, "shares": shares, "asset_type": asset_type}
                )
                db.commit()
                self.log_action("holding_updated", f"Updated {ticker}: {shares} shares ({asset_type})")
                return True, f"Updated {ticker} to {shares:,.2f} shares"
            else:
                db.execute(
                    text("INSERT INTO portfolio_holdings (portfolio_name, ticker, shares, asset_type) VALUES ('Lamido Main', :ticker, :shares, :asset_type)"),
                    {"ticker": ticker, "shares": shares, "asset_type": asset_type}
                )
                db.commit()
                self.log_action("holding_added", f"Added {ticker}: {shares} shares ({asset_type})")
                return True, f"Added {ticker} with {shares:,.2f} shares"
        except Exception as e:
            db.rollback()
            return False, f"Error: {str(e)}"
        finally:
            db.close()
    
    def remove_holding(self, ticker: str) -> Tuple[bool, str]:
        """Remove a holding from the portfolio"""
        from sqlalchemy import text
        from ..storage.database import get_db_session
        
        ticker = ticker.upper().strip()
        db = get_db_session()
        try:
            result = db.execute(
                text("DELETE FROM portfolio_holdings WHERE ticker = :ticker AND portfolio_name = 'Lamido Main'"),
                {"ticker": ticker}
            )
            db.commit()
            
            if result.rowcount > 0:
                self.log_action("holding_removed", f"Removed {ticker}")
                return True, f"Removed {ticker} from portfolio"
            else:
                return False, f"{ticker} not found in portfolio"
        except Exception as e:
            db.rollback()
            return False, f"Error: {str(e)}"
        finally:
            db.close()
    
    def clear_portfolio(self) -> Tuple[bool, str]:
        """Clear all holdings from portfolio"""
        from sqlalchemy import text
        from ..storage.database import get_db_session
        
        db = get_db_session()
        try:
            result = db.execute(
                text("DELETE FROM portfolio_holdings WHERE portfolio_name = 'Lamido Main'")
            )
            db.commit()
            count = result.rowcount
            self.log_action("portfolio_cleared", f"Cleared {count} holdings")
            return True, f"Cleared {count} holdings from portfolio"
        except Exception as e:
            db.rollback()
            return False, f"Error: {str(e)}"
        finally:
            db.close()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # POLYMARKET BTC 15M DIRECTION SKILL
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def analyze_polymarket_direction(
        self,
        market_data: Optional[Dict[str, Any]] = None,
        market_url: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Analyze Polymarket BTC 15m direction

        Args:
            market_data: Pre-scraped market data
            market_url: Polymarket URL (will be scraped if provided and no market_data)

        Returns:
            PolymarketDirectionOutput as dict
        """
        if not POLYMARKET_SKILL_AVAILABLE:
            return {
                "error": "Polymarket BTC 15m skill not installed",
                "message": "The skill module is not available",
            }

        try:
            # If URL provided but no market_data, scrape it
            if market_url and not market_data:
                from skills.polymarket_btc_15m.url_scraper import PolymarketURLScraper
                scraper = PolymarketURLScraper()
                market_data = await scraper.scrape_market_url(market_url)
                self.log_action("polymarket_scrape", f"Scraped market data from {market_url}")

            result = await analyze_btc_15m_direction(
                market_data=market_data,
                market_url=market_url,
                bankroll_usd=5000
            )

            self.log_action("polymarket_analysis", f"Analyzed BTC 15m direction: {result.call.value}")

            # Convert to dict for JSON serialization
            return result.to_dict()

        except Exception as e:
            self.log_error(f"Polymarket analysis failed: {e}")
            return {
                "error": str(e),
                "message": "Analysis failed - check market data format",
            }

    async def quick_polymarket_call(
        self,
        market_data: Dict[str, Any]
    ) -> str:
        """
        Quick "UP", "DOWN", or "NO_TRADE" call

        Args:
            market_data: Pre-scraped market data

        Returns:
            Simple string: "UP", "DOWN", or "NO_TRADE"
        """
        if not POLYMARKET_SKILL_AVAILABLE:
            return "ERROR: Skill not available"

        try:
            return await quick_call(market_data)
        except Exception as e:
            self.log_error(f"Quick call failed: {e}")
            return f"ERROR: {str(e)}"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # EDGELAB BROWSER ADAPTER - Live Data via Agent-Browser
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _get_browser_adapter(self, use_chrome_relay: bool = False) -> Optional["BrowserAdapter"]:
        """
        Get browser adapter instance.
        
        Args:
            use_chrome_relay: If True, uses Clawd Chrome extension for authenticated scraping
        """
        if not EDGELAB_AVAILABLE:
            logger.warning("EdgeLab not available")
            return None
        
        return BrowserAdapter(config={
            "session": "finance_agent",
            "headed": False,
            "timeout": 30000,
            "use_chrome_relay": use_chrome_relay,
        })
    
    async def scrape_live_quote(self, symbol: str, use_chrome_relay: bool = False) -> Dict[str, Any]:
        """
        Scrape live quote for a symbol using browser automation.
        
        Uses agent-browser CLI to scrape Yahoo Finance or other sources.
        Can use Clawd Chrome extension for sites requiring authentication.
        
        Args:
            symbol: Stock/ETF symbol
            use_chrome_relay: Use Clawd Chrome extension (for authenticated sites)
        
        Returns:
            Dict with price, change, volume, etc.
        """
        adapter = self._get_browser_adapter(use_chrome_relay)
        if not adapter:
            return {"error": "Browser adapter not available", "symbol": symbol}
        
        try:
            result = adapter.get_live_quote(symbol)
            self.log_action("browser_scrape", f"Scraped live quote for {symbol}")
            return result
        except Exception as e:
            self.log_error(f"Browser scrape failed for {symbol}: {e}")
            return {"error": str(e), "symbol": symbol}
        finally:
            adapter.cleanup()
    
    async def scrape_market_news(self, symbol: Optional[str] = None) -> List[Dict[str, str]]:
        """
        Scrape market news headlines.
        
        Args:
            symbol: Optional symbol to get news for (None = market news)
        
        Returns:
            List of headline dicts with title, url
        """
        adapter = self._get_browser_adapter()
        if not adapter:
            return []
        
        try:
            headlines = adapter.scrape_news_headlines(symbol)
            self.log_action("news_scrape", f"Scraped {len(headlines)} headlines for {symbol or 'market'}")
            return headlines
        except Exception as e:
            self.log_error(f"News scrape failed: {e}")
            return []
        finally:
            adapter.cleanup()
    
    async def scrape_market_overview(self) -> Dict[str, Any]:
        """
        Scrape overall market overview (indices, sectors).
        
        Returns:
            Dict with indices and market data
        """
        adapter = self._get_browser_adapter()
        if not adapter:
            return {"error": "Browser adapter not available"}
        
        try:
            overview = adapter.scrape_market_overview()
            self.log_action("market_overview_scrape", "Scraped market overview")
            return overview
        except Exception as e:
            self.log_error(f"Market overview scrape failed: {e}")
            return {"error": str(e)}
        finally:
            adapter.cleanup()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # EDGELAB POLYMARKET ADAPTER - Prediction Market Data
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _get_polymarket_adapter(self) -> Optional["PolymarketAdapter"]:
        """Get Polymarket adapter instance"""
        if not EDGELAB_AVAILABLE:
            logger.warning("EdgeLab not available")
            return None
        
        return PolymarketAdapter(config={"timeout": 30})
    
    async def get_polymarket_top_markets(
        self,
        category: Optional[str] = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Get top prediction markets from Polymarket.
        
        Args:
            category: Filter by category (Politics, Crypto, Sports, etc.)
            limit: Max markets to return
        
        Returns:
            List of market dicts with question, yes_price, volume, etc.
        """
        adapter = self._get_polymarket_adapter()
        if not adapter:
            return []
        
        try:
            markets = adapter.get_top_markets(category=category, limit=limit)
            self.log_action("polymarket_fetch", f"Fetched {len(markets)} markets for {category or 'all'}")
            return [m.to_dict() for m in markets]
        except Exception as e:
            self.log_error(f"Polymarket fetch failed: {e}")
            return []
        finally:
            adapter.cleanup()
    
    async def get_polymarket_price(self, market_id_or_slug: str) -> Dict[str, Any]:
        """
        Get live price for a specific Polymarket market.
        
        Args:
            market_id_or_slug: Market ID or slug
        
        Returns:
            Dict with yes_price, no_price, volume, etc.
        """
        adapter = self._get_polymarket_adapter()
        if not adapter:
            return {"error": "Polymarket adapter not available"}
        
        try:
            # Search for the market
            markets = adapter.search_markets(market_id_or_slug, limit=1)
            if not markets:
                return {"error": f"Market not found: {market_id_or_slug}"}
            
            market = markets[0]
            price_data = adapter.get_market_price(market)
            self.log_action("polymarket_price", f"Fetched price for {market.question[:50]}")
            return price_data
        except Exception as e:
            self.log_error(f"Polymarket price fetch failed: {e}")
            return {"error": str(e)}
        finally:
            adapter.cleanup()
    
    async def get_polymarket_sentiment(self, keywords: List[str]) -> Dict[str, Any]:
        """
        Get aggregated sentiment from Polymarket for keywords.
        
        Useful for getting "wisdom of crowds" on topics like:
        - Company earnings ("AAPL earnings beat")
        - Economic events ("Fed rate cut")
        - Crypto events ("ETH ETF approval")
        
        Args:
            keywords: List of search terms
        
        Returns:
            Dict with weighted probability, volume, top markets
        """
        adapter = self._get_polymarket_adapter()
        if not adapter:
            return {"error": "Polymarket adapter not available", "keywords": keywords}
        
        try:
            sentiment = adapter.get_market_sentiment(keywords)
            self.log_action("polymarket_sentiment", f"Analyzed sentiment for {keywords}")
            return sentiment
        except Exception as e:
            self.log_error(f"Polymarket sentiment analysis failed: {e}")
            return {"error": str(e), "keywords": keywords}
        finally:
            adapter.cleanup()
    
    async def search_polymarket(self, query: str, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Search Polymarket markets by text query.
        
        Args:
            query: Search text
            limit: Max results
        
        Returns:
            List of matching markets
        """
        adapter = self._get_polymarket_adapter()
        if not adapter:
            return []
        
        try:
            markets = adapter.search_markets(query, limit=limit)
            self.log_action("polymarket_search", f"Searched '{query}', found {len(markets)} markets")
            return [m.to_dict() for m in markets]
        except Exception as e:
            self.log_error(f"Polymarket search failed: {e}")
            return []
        finally:
            adapter.cleanup()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PORTFOLIO WIZARD
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    async def start_wizard(self) -> str:
        """Start the portfolio wizard"""
        self.wizard_state = {"step": "menu", "data": {}}
        return await self._wizard_menu()

    async def _wizard_menu(self) -> str:
        """Show wizard main menu using LLM"""
        from core.llm_client import get_llm_client
        llm = get_llm_client()

        holdings = self.get_holdings_from_db()
        context = {
            "holdings_count": len(holdings),
            "holdings": holdings
        }

        return await generate_wizard_prompt("menu", context, llm)

    async def _wizard_add_ticker(self) -> str:
        """Ask for ticker using LLM"""
        from core.llm_client import get_llm_client
        llm = get_llm_client()
        return await generate_wizard_prompt("add_ticker", {}, llm)

    async def _wizard_add_shares(self, ticker: str) -> str:
        """Ask for shares using LLM"""
        from core.llm_client import get_llm_client
        llm = get_llm_client()
        return await generate_wizard_prompt("add_shares", {"ticker": ticker}, llm)

    async def _wizard_add_type(self, ticker: str, shares: float) -> str:
        """Ask for asset type using LLM"""
        from core.llm_client import get_llm_client
        llm = get_llm_client()
        return await generate_wizard_prompt("add_type", {"ticker": ticker, "shares": shares}, llm)

    async def _wizard_edit_select(self) -> str:
        """Show holdings to edit using LLM"""
        from core.llm_client import get_llm_client
        llm = get_llm_client()
        holdings = self.get_holdings_from_db()

        if not holdings:
            self.wizard_state = {"step": "menu", "data": {}}
            response = await generate_wizard_prompt("edit_select", {"holdings": []}, llm)
            return response + "\n\n" + await self._wizard_menu()

        self.wizard_state["holdings_list"] = holdings
        return await generate_wizard_prompt("edit_select", {"holdings": holdings}, llm)

    async def _wizard_edit_shares(self, ticker: str, current_shares: float) -> str:
        """Ask for new shares using LLM"""
        from core.llm_client import get_llm_client
        llm = get_llm_client()
        return await generate_wizard_prompt("edit_shares", {"ticker": ticker, "current_shares": current_shares}, llm)

    async def _wizard_remove_select(self) -> str:
        """Show holdings to remove"""
        holdings = self.get_holdings_from_db()
        if not holdings:
            self.wizard_state = {"step": "menu", "data": {}}
            menu = await self._wizard_menu()
            return """â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âŒ **No holdings to remove**
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Your portfolio is empty!

""" + menu

        lines = [
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
            "ğŸ—‘ï¸ **REMOVE HOLDING** (Select one)",
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
            ""
        ]
        for i, h in enumerate(holdings, 1):
            lines.append(f"  **{i}** âœ {h['ticker']}: {h['shares']:,.2f} shares")
        
        lines.append("")
        lines.append("  **0** âœ Back to menu")
        lines.append("")
        lines.append("Reply with a number to remove:")
        lines.append("")
        lines.append("â€” Mamadou ğŸ’°")
        
        self.wizard_state["holdings_list"] = holdings
        return "\n".join(lines)

    async def _wizard_confirm_remove(self, ticker: str, shares: float) -> str:
        """Confirm removal using LLM"""
        from core.llm_client import get_llm_client
        llm = get_llm_client()
        return await generate_wizard_prompt("confirm_remove", {"ticker": ticker, "shares": shares}, llm)

    async def _wizard_confirm_clear(self, count: int) -> str:
        """Confirm clear all using LLM"""
        from core.llm_client import get_llm_client
        llm = get_llm_client()
        return await generate_wizard_prompt("confirm_clear", {"count": count}, llm)

    async def _wizard_view(self) -> str:
        """View portfolio"""
        from core.llm_client import get_llm_client
        llm = get_llm_client()
        holdings = self.get_holdings_from_db()
        return await generate_wizard_prompt("view", {"holdings": holdings}, llm)

    async def process_wizard(self, message: str) -> str:
        """Process wizard input based on current state"""
        step = self.wizard_state.get("step")
        data = self.wizard_state.get("data", {})
        msg = message.strip()

        # Menu selection
        if step == "menu":
            if msg == "1":  # Add holding
                self.wizard_state["step"] = "add_ticker"
                return await self._wizard_add_ticker()
            elif msg == "2":  # Edit holding
                self.wizard_state["step"] = "edit_select"
                return await self._wizard_edit_select()
            elif msg == "3":  # Remove holding
                self.wizard_state["step"] = "remove_select"
                return await self._wizard_remove_select()
            elif msg == "4":  # View portfolio
                return await self._wizard_view()
            elif msg == "5":  # Clear all
                holdings = self.get_holdings_from_db()
                self.wizard_state["step"] = "confirm_clear"
                return await self._wizard_confirm_clear(len(holdings))
            elif msg == "0":  # Exit
                self.wizard_state = {}
                return "âœ… Exited portfolio wizard\n\nâ€” Mamadou ğŸ’°"
            else:
                return "Invalid option. Please enter 0-5.\n\n" + await self._wizard_menu()

        # Add ticker step
        elif step == "add_ticker":
            ticker = msg.upper().strip()
            if ticker and ticker.isalpha():
                data["ticker"] = ticker
                self.wizard_state["step"] = "add_shares"
                self.wizard_state["data"] = data
                return await self._wizard_add_shares(ticker)
            else:
                return "Invalid ticker. Please enter a valid ticker symbol.\n\n" + await self._wizard_add_ticker()

        # Add shares step
        elif step == "add_shares":
            try:
                shares = float(msg.replace(",", ""))
                if shares <= 0:
                    return "Shares must be positive.\n\n" + await self._wizard_add_shares(data.get("ticker"))
                data["shares"] = shares
                self.wizard_state["step"] = "add_type"
                self.wizard_state["data"] = data
                return await self._wizard_add_type(data["ticker"], shares)
            except ValueError:
                return "Invalid number. Please enter number of shares.\n\n" + await self._wizard_add_shares(data.get("ticker"))

        # Add type step
        elif step == "add_type":
            type_map = {"1": "Stock", "2": "ETF", "3": "Tech", "4": "Crypto", "5": "Gold", "6": "Dividend", "7": "Other"}
            asset_type = type_map.get(msg, msg)
            ticker = data.get("ticker")
            shares = data.get("shares")

            success, result = self.add_holding(ticker, shares, asset_type)
            self.wizard_state = {}  # Exit wizard after adding
            return f"{'âœ…' if success else 'âŒ'} {result}\n\nâ€” Mamadou ğŸ’°"

        # Edit select step
        elif step == "edit_select":
            holdings_list = self.wizard_state.get("holdings_list", [])
            try:
                choice = int(msg)
                if choice == 0:
                    self.wizard_state["step"] = "menu"
                    return await self._wizard_menu()
                elif 1 <= choice <= len(holdings_list):
                    selected = holdings_list[choice - 1]
                    data["ticker"] = selected["ticker"]
                    data["current_shares"] = selected["shares"]
                    self.wizard_state["step"] = "edit_shares"
                    self.wizard_state["data"] = data
                    return await self._wizard_edit_shares(selected["ticker"], selected["shares"])
                else:
                    return f"Invalid choice. Enter 0-{len(holdings_list)}\n\n" + await self._wizard_edit_select()
            except ValueError:
                return "Invalid input. Enter a number.\n\n" + await self._wizard_edit_select()

        # Edit shares step
        elif step == "edit_shares":
            try:
                shares = float(msg.replace(",", ""))
                if shares <= 0:
                    return "Shares must be positive.\n\n" + await self._wizard_edit_shares(data.get("ticker"), data.get("current_shares"))

                ticker = data.get("ticker")
                success, result = self.add_holding(ticker, shares, "Stock")  # Keep existing type
                self.wizard_state = {}
                return f"{'âœ…' if success else 'âŒ'} {result}\n\nâ€” Mamadou ğŸ’°"
            except ValueError:
                return "Invalid number.\n\n" + await self._wizard_edit_shares(data.get("ticker"), data.get("current_shares"))

        # Remove select step
        elif step == "remove_select":
            holdings_list = self.wizard_state.get("holdings_list", [])
            try:
                choice = int(msg)
                if choice == 0:
                    self.wizard_state["step"] = "menu"
                    return await self._wizard_menu()
                elif 1 <= choice <= len(holdings_list):
                    selected = holdings_list[choice - 1]
                    data["ticker"] = selected["ticker"]
                    data["shares"] = selected["shares"]
                    self.wizard_state["step"] = "confirm_remove"
                    self.wizard_state["data"] = data
                    return await self._wizard_confirm_remove(selected["ticker"], selected["shares"])
                else:
                    return f"Invalid choice. Enter 0-{len(holdings_list)}\n\n" + await self._wizard_remove_select()
            except ValueError:
                return "Invalid input. Enter a number.\n\n" + await self._wizard_remove_select()

        # Confirm remove step
        elif step == "confirm_remove":
            if msg.lower() in ["yes", "y", "1"]:
                ticker = data.get("ticker")
                success, result = self.remove_holding(ticker)
                self.wizard_state = {}
                return f"{'âœ…' if success else 'âŒ'} {result}\n\nâ€” Mamadou ğŸ’°"
            else:
                self.wizard_state["step"] = "menu"
                return "Cancelled removal.\n\n" + await self._wizard_menu()

        # Confirm clear step
        elif step == "confirm_clear":
            if msg.lower() in ["yes", "y", "1"]:
                success, result = self.clear_portfolio()
                self.wizard_state = {}
                return f"{'âœ…' if success else 'âŒ'} {result}\n\nâ€” Mamadou ğŸ’°"
            else:
                self.wizard_state["step"] = "menu"
                return "Cancelled clear.\n\n" + await self._wizard_menu()

        # Unknown step
        else:
            self.wizard_state = {}
            return "Wizard error. Restarting...\n\nâ€” Mamadou ğŸ’°"


    async def quick_btc_direction(self) -> str:
        """Quick trade direction via Chrome extension"""
        try:
            from .browser_polymarket import ChromeExtensionTrader
            trader = ChromeExtensionTrader(agent_name="finance_trader")
            await trader.initialize()
            return await trader.quick_direction()
        except Exception as e:
            self.log_error(f"BTC trading bot error: {e}")
            return f"âŒ Trading bot failed: {str(e)}\n\nâ€” {self.emoji}"
    async def chat(self, message: str, conversation_history: List[Dict[str, str]] = None) -> str:
        """Handle finance-related chat with conversation history"""
        msg_lower = message.lower().strip()

        # BTC trading bot commands
        if any(phrase in msg_lower for phrase in ["up or down", "btc direction", "btc 15m", "analyze btc"]):
            return await self.quick_btc_direction()
        
        elif any(phrase in msg_lower for phrase in ["start monitor", "monitor btc", "continuous", "watch btc"]):
            if "start" in msg_lower or "monitor" in msg_lower:
                try:
                    from .browser_polymarket import ChromeExtensionTrader
                    trader = ChromeExtensionTrader(agent_name="finance_trader")
                    await trader.initialize()
                    asyncio.create_task(trader.monitor_continuous())
                    return f"ğŸ”” BTC monitoring started!\nWill alert on high-confidence signals.\n\nâ€” {self.emoji}"
                except Exception as e:
                    return f"âŒ Failed to start monitoring: {e}\n\nâ€” {self.emoji}"
        
        elif "stop monitor" in msg_lower:
            return f"ğŸ”” BTC monitoring stopped.\n\nâ€” {self.emoji}"
        
        elif "chrome" in msg_lower or "extension" in msg_lower:
            return f"""ğŸ”— **Chrome Extension Status**

For BTC trading bot:
1. Install Clawdbot Chrome extension
2. Click extension icon â†’ badge should show "ON"
3. Navigate to Polymarket BTC 15m market
4. Say "up or down" to analyze

Extension enables:
â€¢ Live page scraping (no copy/paste)
â€¢ Authenticated session access
â€¢ Current tab detection
â€¢ Real-time data extraction

â€” {self.emoji}"""

        # Check if wizard is active
        if self.wizard_state.get("step"):
            return await self.process_wizard(message)

        # Polymarket BTC 15m direction query
        if any(phrase in msg_lower for phrase in ["up or down", "btc direction", "polymarket", "btc 15m"]):
            if POLYMARKET_SKILL_AVAILABLE:
                return ("ğŸ¯ **Polymarket BTC 15m Direction Analysis**\n\n"
                       "I'm ready to analyze BTC direction for 15-minute markets!\n\n"
                       "**To use this feature:**\n"
                       "1. Go to the **Finance page**\n"
                       "2. Find the **BTC 15m Prediction** section\n"
                       "3. Provide market data or URL\n"
                       "4. Click **Analyze Direction**\n\n"
                       "I'll give you a detailed call (UP/DOWN/NO_TRADE) with confidence level "
                       "and 6+ reasons backed by EDGE_SCORE v1.0.\n\n"
                       "â€” Mamadou ğŸ’°")
            else:
                return ("âŒ Polymarket BTC 15m skill not installed.\n\n"
                       "Contact system administrator to enable this feature.\n\n"
                       "â€” Mamadou ğŸ’°")

        # Start wizard
        if "wizard" in msg_lower or "manage portfolio" in msg_lower:
            return await self.start_wizard()
        
        # Quick commands still work outside wizard
        if "clear" in msg_lower and "portfolio" in msg_lower:
            success, result = self.clear_portfolio()
            return f"{'âœ…' if success else 'âŒ'} {result}\n\nâ€” Mamadou ğŸ’°"
        
        if any(word in msg_lower for word in ["remove", "delete", "sell"]):
            ticker = self._parse_remove_command(message)
            if ticker:
                success, result = self.remove_holding(ticker)
                return f"{'âœ…' if success else 'âŒ'} {result}\n\nâ€” Mamadou ğŸ’°"
        
        if any(word in msg_lower for word in ["add", "buy"]) and any(c.isdigit() for c in message):
            parsed = self._parse_add_command(message)
            if parsed:
                success, result = self.add_holding(parsed["ticker"], parsed["shares"], parsed["asset_type"])
                return f"{'âœ…' if success else 'âŒ'} {result}\n\nâ€” Mamadou ğŸ’°"
        
        # Show portfolio
        if "portfolio" in msg_lower or "holdings" in msg_lower or "positions" in msg_lower:
            holdings = self.get_holdings_from_db()
            if holdings:
                lines = ["ğŸ“Š **Your Portfolio:**"]
                for h in holdings:
                    lines.append(f"  â€¢ **{h['ticker']}**: {h['shares']:,.2f} shares ({h['type']})")
                lines.append("")
                lines.append("ğŸ’¡ Say **wizard** to manage your portfolio")
                self.log_action("portfolio_viewed", f"Showed {len(holdings)} holdings")
                return "\n".join(lines) + f"\n\nâ€” Mamadou ğŸ’°"
            else:
                return "ğŸ“Š Your portfolio is empty.\n\nğŸ’¡ Say **wizard** to add holdings!\n\nâ€” Mamadou ğŸ’°"
        
        # EdgeLab: Live quote scraping
        if any(phrase in msg_lower for phrase in ["live quote", "scrape price", "current price"]):
            if not EDGELAB_AVAILABLE:
                return "âŒ EdgeLab adapters not available for live scraping.\n\nâ€” Mamadou ğŸ’°"
            
            # Try to extract ticker
            words = message.upper().split()
            tickers = [w for w in words if w.isalpha() and 1 <= len(w) <= 5 and w not in {'LIVE', 'QUOTE', 'PRICE', 'SCRAPE', 'FOR', 'OF', 'THE', 'GET', 'SHOW', 'CURRENT'}]
            if tickers:
                ticker = tickers[0]
                result = await self.scrape_live_quote(ticker)
                if result.get("error"):
                    return f"âŒ Failed to scrape {ticker}: {result['error']}\n\nâ€” Mamadou ğŸ’°"
                
                return (f"ğŸ“ˆ **Live Quote for {ticker}**\n\n"
                       f"â€¢ Price: {result.get('price', 'N/A')}\n"
                       f"â€¢ Change: {result.get('change', 'N/A')} ({result.get('change_pct', 'N/A')})\n"
                       f"â€¢ Source: {result.get('source', 'browser')}\n"
                       f"â€¢ Time: {result.get('timestamp', 'now')}\n\n"
                       "â€” Mamadou ğŸ’°")
            
            return "ğŸ’¡ Specify a ticker: `live quote AAPL`\n\nâ€” Mamadou ğŸ’°"
        
        # EdgeLab: Polymarket markets
        if any(phrase in msg_lower for phrase in ["prediction market", "polymarket market", "betting odds"]):
            if not EDGELAB_AVAILABLE:
                return "âŒ EdgeLab adapters not available.\n\nâ€” Mamadou ğŸ’°"
            
            # Detect category
            category = None
            if "politic" in msg_lower:
                category = "Politics"
            elif "crypto" in msg_lower:
                category = "Crypto"
            elif "sport" in msg_lower:
                category = "Sports"
            
            markets = await self.get_polymarket_top_markets(category=category, limit=5)
            if not markets:
                return "âŒ No markets found.\n\nâ€” Mamadou ğŸ’°"
            
            lines = [f"ğŸ¯ **Top Polymarket Markets{' - ' + category if category else ''}**\n"]
            for m in markets:
                prob = m.get('implied_probability', m.get('yes_price', 0))
                lines.append(f"â€¢ **{m['question'][:60]}...**")
                lines.append(f"  Probability: {prob*100:.1f}% | Volume: ${m.get('volume', 0):,.0f}")
            
            lines.append("")
            lines.append("ğŸ’¡ Ask about sentiment: `polymarket sentiment Fed rate cut`")
            return "\n".join(lines) + "\n\nâ€” Mamadou ğŸ’°"
        
        # EdgeLab: Polymarket sentiment
        if "polymarket sentiment" in msg_lower or "prediction sentiment" in msg_lower:
            if not EDGELAB_AVAILABLE:
                return "âŒ EdgeLab adapters not available.\n\nâ€” Mamadou ğŸ’°"
            
            # Extract keywords after "sentiment"
            parts = message.lower().split("sentiment")
            if len(parts) > 1:
                keywords = [k.strip() for k in parts[1].split() if len(k.strip()) > 2]
                if keywords:
                    sentiment = await self.get_polymarket_sentiment(keywords)
                    if sentiment.get("error"):
                        return f"âŒ Sentiment analysis failed: {sentiment['error']}\n\nâ€” Mamadou ğŸ’°"
                    
                    lines = [f"ğŸ”® **Polymarket Sentiment: {', '.join(keywords)}**\n"]
                    lines.append(f"â€¢ Markets Found: {sentiment.get('markets_found', 0)}")
                    
                    if sentiment.get('weighted_avg_probability') is not None:
                        prob = sentiment['weighted_avg_probability']
                        lines.append(f"â€¢ Weighted Probability: {prob*100:.1f}%")
                        lines.append(f"â€¢ Total Volume: ${sentiment.get('total_volume', 0):,.0f}")
                        
                        if sentiment.get('markets'):
                            lines.append("\n**Top Markets:**")
                            for m in sentiment['markets'][:3]:
                                lines.append(f"â€¢ {m.get('question', 'N/A')[:50]}...")
                                lines.append(f"  â†’ {m.get('yes_price', 0)*100:.1f}% likely")
                    
                    return "\n".join(lines) + "\n\nâ€” Mamadou ğŸ’°"
            
            return "ğŸ’¡ Specify keywords: `polymarket sentiment Fed rate cut`\n\nâ€” Mamadou ğŸ’°"
        
        # Help
        if "help" in msg_lower:
            help_text = """ğŸ’° **Mamadou - Finance Agent**

**Portfolio Wizard:**
â€¢ Say **wizard** to open the interactive portfolio manager

**Quick Commands:**
â€¢ `show portfolio` - View holdings
â€¢ `add 100 AAPL` - Quick add
â€¢ `remove AAPL` - Quick remove"""
            
            if EDGELAB_AVAILABLE:
                help_text += """

**EdgeLab Data:**
â€¢ `live quote AAPL` - Scrape live price
â€¢ `prediction market crypto` - Top Polymarket markets
â€¢ `polymarket sentiment BTC halving` - Crowd wisdom"""
            
            return help_text + "\n\nâ€” Mamadou ğŸ’°"
        
        # Fall back to AI
        return await super().chat(message)

    def _parse_add_command(self, message: str) -> Optional[Dict[str, Any]]:
        """Parse add holding command from natural language"""
        msg = message.upper()
        excluded_words = {'ADD', 'BUY', 'SHARES', 'SHARE', 'OF', 'THE', 'MY', 'SOME', 'MORE'}
        
        patterns = [
            r'ADD\s+(\d+(?:\.\d+)?)\s+([A-Z]{1,5})(?:\s|$)',
            r'(\d+(?:\.\d+)?)\s+SHARES?\s+OF\s+([A-Z]{1,5})',
            r'BUY\s+(\d+(?:\.\d+)?)\s+([A-Z]{1,5})',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, msg)
            if match:
                g1, g2 = match.groups()
                if g1.replace('.', '').isdigit():
                    shares, ticker = float(g1), g2
                else:
                    ticker, shares = g1, float(g2)
                
                if ticker in excluded_words:
                    continue
                
                asset_type = "Stock"
                type_patterns = {
                    r'\bETF\b': 'ETF', r'\bTECH\b': 'Tech', r'\bGOLD\b': 'Gold',
                    r'\bBTC\b|\bCRYPTO\b': 'Crypto', r'\bDIVIDEND\b': 'Dividend',
                }
                for tp, tn in type_patterns.items():
                    if re.search(tp, msg):
                        asset_type = tn
                        break
                
                return {"ticker": ticker, "shares": shares, "asset_type": asset_type}
        return None

    def _parse_remove_command(self, message: str) -> Optional[str]:
        """Parse remove holding command"""
        msg = message.upper()
        patterns = [r'(?:REMOVE|DELETE|SELL)\s+([A-Z]{1,5})']
        for pattern in patterns:
            match = re.search(pattern, msg)
            if match:
                return match.group(1)
        return None


# Backwards compatibility
FinanceManager = FinanceAgent
